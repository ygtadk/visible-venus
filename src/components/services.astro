---
import {
  getLangFromUrl,
  useTranslations,
} from "../i18n/utils";
import { ui, defaultLang } from "../i18n/ui";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

type UIKey = keyof typeof ui[typeof defaultLang];

const services: {
  svgPath: string;
  titleKey: UIKey;
  descKey: UIKey;
}[] = [
  {
    svgPath: "M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM4 18V8h16v10H4z",
    titleKey: "services.web.title",
    descKey: "services.web.desc",
  },
  {
    svgPath: "M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",
    titleKey: "services.software.title",
    descKey: "services.software.desc",
  },
  {
    svgPath: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z",
    titleKey: "services.cloud.title",
    descKey: "services.cloud.desc",
  },
  {
    svgPath: "M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z",
    titleKey: "services.consulting.title",
    descKey: "services.consulting.desc",
  },
  {
    svgPath: "M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z",
    titleKey: "services.security.title",
    descKey: "services.security.desc",
  },
  {
    svgPath: "M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z",
    titleKey: "services.mobile.title",
    descKey: "services.mobile.desc",
  },
];
---

<!-- Services Component -->
<section id="services" class="relative h-screen w-full bg-neutral-900 overflow-hidden">
  <!-- Progress Indicator -->
  <div class="absolute inset-0 z-50 pointer-events-none flex items-center justify-center">
    <div class="w-full max-w-7xl px-6 relative h-full">
      <div class="absolute left-6 top-1/2 -translate-y-1/2 flex flex-col gap-4 hidden md:flex pointer-events-auto">
        {services.map((_, index) => (
          <div 
            class="service-dot w-1 h-8 bg-neutral-700 rounded-full transition-all duration-300"
            data-index={index}>
          </div>
        ))}
      </div>
    </div>
  </div>

  <!-- Slides -->
  {services.map((service, index) => (
    <div 
      class="service-panel absolute inset-0 w-full h-full bg-neutral-900"
      style={`z-index: ${index + 1};`}>
      
      <div class="container mx-auto px-6 h-full flex items-center">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center w-full">
          
          <!-- Left: Visual (Vector Graphic) -->
          <div class="service-visual flex justify-center lg:justify-end opacity-0 translate-y-10">
            <div class="w-64 h-64 md:w-96 md:h-96 bg-neutral-800/50 rounded-3xl flex items-center justify-center relative overflow-hidden group border border-neutral-700/50 shadow-2xl">
               <!-- SVG -->
               <svg viewBox="0 0 24 24" class="w-32 h-32 text-green-400 transition-transform duration-700 group-hover:scale-110 group-hover:rotate-3" fill="currentColor">
                 <path d={service.svgPath} />
               </svg>
               
               <!-- Decorative Glow -->
               <div class="absolute inset-0 bg-linear-to-tr from-green-500/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500"></div>
               <div class="absolute -bottom-10 -right-10 w-40 h-40 bg-green-500/20 blur-[60px] rounded-full"></div>
            </div>
          </div>

          <!-- Right: Content -->
          <div class="service-content text-center lg:text-left opacity-0 translate-y-10">
             <h2 class="text-4xl md:text-6xl font-bold text-white mb-6 leading-tight">
               {t(service.titleKey)}
             </h2>
             <p class="text-xl text-neutral-400 leading-relaxed max-w-xl mx-auto lg:mx-0">
               {t(service.descKey)}
             </p>
             
             <!-- Optional: Learn More Link/Button -->
             {/* <div class="mt-8">
               <a href="#" class="inline-flex items-center gap-2 text-green-400 font-medium hover:text-green-300 transition-colors group">
                 <span>Daha Fazla</span>
                 <svg class="w-4 h-4 transition-transform group-hover:translate-x-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
               </a>
             </div> */}
          </div>

        </div>
      </div>

      <!-- Decorative Background (Optional, subtle) -->
      <div class="absolute inset-0 pointer-events-none opacity-5">
        <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-white rounded-full blur-[128px]"></div>
      </div>
    </div>
  ))}
</section>
<!-- End Services Component -->

<!-- Services Component Script -->
<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  const wrapper = document.querySelector("#services");
  const panels = gsap.utils.toArray(".service-panel") as HTMLElement[];
  const dots = document.querySelectorAll(".service-dot");

  // Initial setup: 
  // First panel is visible. 
  // Others are positioned down (y: 100%) so they can slide up.
  // Actually, for "stacking" effect where they slide OVER each other:
  // Panel 0 is static.
  // Panel 1 slides up over Panel 0.
  // Panel 2 slides up over Panel 1.
  
  // We need to set initial state for panels 1 to N
  panels.forEach((panel, i) => {
    if (i !== 0) {
      gsap.set(panel, { yPercent: 100 });
    }
  });

  const tl = gsap.timeline({
    scrollTrigger: {
      trigger: wrapper,
      start: "top top",
    end: "+=" + (panels.length * 75) + "%", // Reduced scroll distance
    pin: true,
    scrub: 0.5,
    snap: 1 / (panels.length - 1), // Snap to each panel
    }
  });

  // Create animations for each panel transition
  panels.forEach((panel, i) => {
    if (i === 0) return; // Skip first panel

    // 1. Panel Slide Up
    tl.fromTo(panel, 
      { yPercent: 100, opacity: 0 },
      {
        yPercent: 0,
        opacity: 1,
        ease: "power2.inOut",
        duration: 1
      }
    );

    // 2. Visual Slide In (from left/bottom)
    tl.fromTo(panel.querySelector('.service-visual'), 
      { opacity: 0, x: -50, scale: 0.9 }, 
      { opacity: 1, x: 0, scale: 1, duration: 0.6, ease: "back.out(1.7)" }, 
      "<0.2"
    );

    // 3. Content Slide In (from right/bottom)
    tl.fromTo(panel.querySelector('.service-content'), 
      { opacity: 0, x: 50 }, 
      { opacity: 1, x: 0, duration: 0.6, ease: "power2.out" }, 
      "<0.1"
    );
  });

  // Initial content animation for the first panel
  const firstPanel = panels[0];
  gsap.to(firstPanel.querySelector('.service-visual'), {
    opacity: 1,
    y: 0,
    x: 0,
    duration: 1,
    ease: "power2.out",
    scrollTrigger: {
      trigger: wrapper,
      start: "top 60%",
    }
  });
  
  gsap.to(firstPanel.querySelector('.service-content'), {
    opacity: 1,
    y: 0,
    x: 0,
    duration: 1,
    delay: 0.2,
    ease: "power2.out",
    scrollTrigger: {
      trigger: wrapper,
      start: "top 60%",
    }
  });

  // Progress Indicator Logic
  // We can use a separate ScrollTrigger or update inside the timeline
  panels.forEach((_, i) => {
    ScrollTrigger.create({
      trigger: wrapper,
      start: () => "top top+=" + (i * window.innerHeight), // Approximate trigger points
      end: () => "top top+=" + ((i + 1) * window.innerHeight),
      // This logic is tricky with pinned scrub. 
      // Better to use the timeline's progress or just simple callbacks.
    });
  });

  // Simpler progress update:
  // Calculate active index based on scroll progress of the main trigger
  tl.eventCallback("onUpdate", () => {
    const progress = tl.progress();
    // progress goes 0 -> 1
    // We have panels.length segments? 
    // Actually we have (panels.length - 1) transitions.
    // Let's map progress to index.
    // 0.0 - 0.2 -> Index 0 (if 5 transitions)
    
    const totalTransitions = panels.length - 1;
    const index = Math.min(Math.floor(progress * panels.length), panels.length - 1);
    
    // Or slightly better mapping
    // If progress is 0, index 0.
    // If progress is > 0 but < 1/N, index 1 is coming in?
    
    // Let's just highlight based on which panel is "mostly" visible.
    // Since they stack, the highest index with yPercent < 100 is active?
    // Actually, the timeline animates them sequentially.
    
    // Let's use a simpler approach for dots:
    // Just highlight the one corresponding to the current "page"
    // Since we scrub, we can calculate it.
    
    const currentIndex = Math.round(progress * (panels.length - 1));
    
    dots.forEach((dot, i) => {
      if (i === currentIndex) {
        dot.classList.add("bg-green-400", "h-12");
        dot.classList.remove("bg-neutral-700", "h-8");
      } else {
        dot.classList.remove("bg-green-400", "h-12");
        dot.classList.add("bg-neutral-700", "h-8");
      }
    });
  });
  
  // Initialize first dot
  dots[0].classList.add("bg-green-400", "h-12");
  dots[0].classList.remove("bg-neutral-700", "h-8");

</script>
<!-- End Services Component Script -->
